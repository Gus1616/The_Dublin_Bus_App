var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { defineComponent, ref, onMounted, watch, nextTick, openBlock, createElementBlock, Fragment, renderSlot, createCommentVNode, createElementVNode, mergeProps } from "vue";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const langs = [
  "ar",
  "bn",
  "cs",
  "da",
  "de",
  "el",
  "en",
  "es",
  "fa",
  "fi",
  "fil",
  "fr",
  "he",
  "hi",
  "hu",
  "id",
  "it",
  "ja",
  "ko",
  "msa",
  "nl",
  "no",
  "pl",
  "pt",
  "ro",
  "ru",
  "sv",
  "th",
  "tr",
  "uk",
  "ur",
  "vi",
  "zh-cn",
  "zh-tw"
];
const TWEET_URL_REGEX = /^(https?:\/\/)?(www\.)?twitter\.com\/.*\/status(?:es)?\/(?<tweetId>[^\/\?]\d+)$/i;
const _sfc_main = defineComponent({
  props: {
    tweetId: {
      type: String,
      default: ""
    },
    tweetUrl: {
      type: String,
      default: ""
    },
    conversation: {
      type: String,
      default: "all",
      validator: (value) => ["all", "none"].includes(value)
    },
    cards: {
      type: String,
      default: "visible",
      validator: (value) => ["visible", "hidden"].includes(value)
    },
    width: {
      type: [String, Number],
      default: "auto",
      validator: (value) => {
        if (typeof value === "string") {
          return value === "auto";
        }
        if (typeof value === "number") {
          return value >= 250 && value <= 550;
        }
        return false;
      }
    },
    align: {
      type: [String, void 0],
      default: void 0,
      validator: (value) => ["left", "right", "center", void 0].includes(value)
    },
    theme: {
      type: String,
      default: "light",
      validator: (value) => ["light", "dark"].includes(value)
    },
    lang: {
      type: String,
      default: "en",
      validator: (value) => langs.includes(value)
    },
    dnt: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "tweet-load-success": (twitterWidgetElement) => !!twitterWidgetElement,
    "tweet-load-error": () => true
  },
  setup(props, { attrs, emit }) {
    const isLoading = ref(true);
    const hasError = ref(false);
    const tweetContainerRef = ref();
    onMounted(() => {
      renderTweet();
    });
    watch(props, () => {
      renderTweet();
    });
    function renderTweet() {
      if (!(window["twttr"] && window["twttr"].ready)) {
        addScript("https://platform.twitter.com/widgets.js", renderTweet);
        return;
      }
      window["twttr"].ready().then(({ widgets }) => {
        isLoading.value = true;
        hasError.value = false;
        if (tweetContainerRef.value) {
          tweetContainerRef.value.innerHTML = "";
        }
        const { tweetId, tweetOptions } = getTweetParams();
        widgets.createTweet(tweetId, tweetContainerRef.value, tweetOptions).then(async (twitterWidgetElement) => {
          await nextTick();
          if (twitterWidgetElement) {
            emit("tweet-load-success", twitterWidgetElement);
          } else {
            hasError.value = true;
            emit("tweet-load-error");
          }
        }).finally(() => {
          isLoading.value = false;
        });
      });
    }
    function getTweetParams() {
      var _b;
      let _a = props, { tweetId, tweetUrl } = _a, tweetOptions = __objRest(_a, ["tweetId", "tweetUrl"]);
      if (tweetId && tweetUrl) {
        throw new Error("Cannot provide both tweet-id and tweet-url.");
      } else if (tweetId) {
        if (!/^\d+$/.test(tweetId)) {
          throw new Error("Invalid tweet-id, please provide a valid numerical tweet-id.");
        }
      } else if (tweetUrl) {
        const match = tweetUrl.trim().match(TWEET_URL_REGEX);
        if (match) {
          tweetId = (_b = match.groups) == null ? void 0 : _b.tweetId;
        } else {
          throw new Error("Invalid tweet-url.");
        }
      } else {
        throw new Error("Must provide either tweet-id or tweet-url.");
      }
      return {
        tweetId,
        tweetOptions
      };
    }
    function addScript(src, cb) {
      const s = document.createElement("script");
      s.setAttribute("src", src);
      s.addEventListener("load", () => cb(), false);
      document.body.appendChild(s);
    }
    return { tweetContainerRef, isLoading, hasError, attrs };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.isLoading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : _ctx.hasError ? renderSlot(_ctx.$slots, "error", { key: 1 }) : createCommentVNode("", true),
    createElementVNode("div", mergeProps({ ref: "tweetContainerRef" }, _ctx.attrs), null, 16)
  ], 64);
}
var vueTweet = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { vueTweet as default };
